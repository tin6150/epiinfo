---
title: "analysis for Shrimp Ecuador 2023 data"
date: "2024-07-20"
output:
  html_document: default
  pdf_document: default
---



Tilden started a maper, MDPI reviwer has request...
data submission to GenBank, Niko found missing fasta for the "I" sample.


v2, reanalyze the data (MLST and Abricate result) myself.
only use Tilden's file for sample metadata info.

dropped comparison stuff
will add additional analysis to reproduce table/charts for paper.

```{r pre_setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
print( "hope this setup_knit thing doesnt cause next setup section not to run, just cuz it had no runnable code in this chunk?")

# install.packages( "pak" )  # another package manager.
# pak::pak( "ggtext" ). # seems like failing on zyzyxia3 as well.  on a dep png
# pak::pak( "ggtext" )  # is this like p_load? won't install if already installed?

```

```{r setup}

library( pacman )
p_load( tidyverse )
p_load( dplyr )
# @importFrom dplyr select
p_load( readr )
p_load( stringr )
# library(RColorBrewer)



# fn alias 
`%nin%` = Negate(`%in%`)
# no is.nna(), so just do !is.na()

# open all input files here in the setup block
# so know early on if have all necessary


####
#### read input, which is output from Abricate
####



# DATADIR="/global/scratch/users/tin/fc_graham/ecuador_2023_TJ/Sequences/Tilden/ALL/assembled-sequences_par3"  # sav
DATADIR="result/"


####
#### MLST SeqType info
####
mlst_tsv_file = sprintf( "%s/%s", DATADIR, "mlst.all.tsv") 
mlst_tsv = read_tsv( mlst_tsv_file )


####
#### resistance gene were focus of paper
####
resfind_sum_file = sprintf( "%s/%s", DATADIR, "Abricate_resfinder_summary.csv") 
resfind_sum_tmp_tsv = read_tsv( resfind_sum_file, col_types = list( .default=col_character() ) )
resfind_sum_tsv = type_convert( resfind_sum_tmp_tsv )  # here, expect only NUM_FOUND is converted as double.


resfind_sum_pct_df = resfind_sum_tsv %>%
  rename( file_name = '#FILE' ,
          RESIST_NUM_FOUND = "NUM_FOUND"
          ) 



####
##### VFDB was not used by Tilden in the paper, but want to use it to sanity check that Abricate can run on fasta file, eg L, BC, as 9 records has no resfinder output.
####
vfdb_sum_file = sprintf( "%s/%s", DATADIR, "Abricate_vfdb_summary.csv")
vfdb_sum_tmp_tsv = read_tsv( vfdb_sum_file, col_types = list( .default=col_character() ) )
vfdb_sum_tsv = type_convert( vfdb_sum_tmp_tsv )  # here, expect only NUM_FOUND is converted as double.


# ecoli_vf said to be vfdb + gene from literatur, so more extensive https://github.com/phac-nml/ecoli_vf
# trying it hoping as plug-in replacement to vfdb_sum_tsv
# actually, vfdb maybe more aligned with publication, but using ecoli_vf to check if samples might be dup.
ecvf_sum_file = sprintf( "%s/%s", DATADIR, "Abricate_ecoli_vf_summary.csv" )
ecvf_sum_tmp_tsv = read_tsv( ecvf_sum_file, col_types = list( .default=col_character() ) )
ecvf_sum_tsv = type_convert( ecvf_sum_tmp_tsv )  # here, expect only NUM_FOUND is converted as double.

## 

# Choose: VFDB vs ECVF for source of vfg
# Using VFDB

abricate_vfdb_sum_tsv = vfdb_sum_tsv    # both vfdb and
#abricate_vfdb_sum_tsv = ecvf_sum_tsv   # ecvf here will be used to see if can tell dups.



# rest of code will be unchanged to use vfdb_sum_df
# 2024.0315, vfdb_sum_df get the jgrg result joined into it

vfdb_sum_pct_df = abricate_vfdb_sum_tsv %>%
  rename( file_name = '#FILE' ,
          VFDB_NUM_FOUND = "NUM_FOUND"
          )


# View(vfdb_sum_df)

ecvf_sum_pct_df = ecvf_sum_tsv %>%
  rename( file_name = '#FILE' ,
          ECVF_NUM_FOUND = "NUM_FOUND"
          )
  


####
#### resistance gene, Tilden used the long version (ie 1 gene per line, rather than the wide version)
####
# later will add sample metadata info to create resfinder_labeled
resfind_long_file = sprintf( "%s/%s", DATADIR, "Abricate_resfinder_combined.csv") 
resfind_long_tmp_tsv = read_tsv( resfind_long_file, col_types = list( .default=col_character() ) )
resfind_long_tsv = type_convert( resfind_long_tmp_tsv )  # here, expect only NUM_FOUND is converted as double.

resfind_long_pct_df = resfind_long_tsv %>%
  rename( file_name = '#FILE' ,
          gene = 'GENE' 
          ) 
```

##############################################################################
```{r readTR, eval=T}
# reading in files from Tilden for sample info (metadata)
# shared folder:
# https://drive.google.com/drive/folders/1kk-56BYRkYOXJtascCi6LEkVxE-mO0aW
#
# files:
# https://docs.google.com/spreadsheets/d/18qKB7kIbr1adVEm0Ws56eiJPc1ZCX6T55yMw-h10PT8/edit?gid=646212993#gid=646212993
# https://docs.google.com/spreadsheets/d/15P318xrNscGkKK-ls2IUuM3HVyXZy7BhNdxrvVPiYZw/edit?gid=0#gid=0

# ref: https://docs.google.com/document/d/1mP5gzfIKnpeE80osPNdE_b_Gev6pQ6_elGxjC7httpM/edit 

CACHEDIR="CACHE"  # tmp subfolder, files not checked into git repo

ResMlstCombTableTsv50  = sprintf( "%s/50_Sample\ Info\ Added_mlst.all\ -\ mlst.all.tsv", CACHEDIR )   
ResMlstCombTable50     = read_tsv( ResMlstCombTableTsv50 ) %>%    # edited header 
  rename( file_name = 'Filename' )
# 50 rows.  this file were noted to have dupliates, but did not match the fasta dups I found.  so using this.

specieName = read_tsv( "metadata/specieName.tsv" )

```

```{r setup_part2}

# read sample_metadata_withDupInfo , where rows that should be filtered out as duplicate has text in a new column indicating it is a duplicate sample

sample_metadata_withDupInfo     = read_tsv( "metadata/sample_metadata_withDupInfo.tsv" )    # hand edited

# sample_metadata_withDupInfo.tsv is hand edited, from sample_metadata.tsv geneated by early generation of this script
# bootstrapping :D

```

# create join key for  mlst  resfinder result
likely just the first 1-2 letter of the filename should suffice
eg for mlst:   (has 55 rows, sample "I" is missing)
AA_CKDN230030154-1A_HGKHYDSX7_L2.fasta
 J_CKDN230030143-1A_HGKHYDSX7_L2.fasta
2^ ^^^^3^^^^^^^^ 4^ ^5^^^^^^^ ^6 

eg for ecoli_vf_summary
AA_CKDN230030154-1A_HGKHYDSX7_L2_Abricate_ecoli_vf.tsv
2^ ^^^^3^^^^^^^^ 4^ ^5^^^^^^^ ^6 

eg for resfinder:  (has 56 rows, sample "I" is present)    ie the wide/summary version
I_CKDN230030142-1A_HGKHYDSX7_L2_Abricate_resfinder.tsv
2 ^^^^3^^^^^^^^ 4^ ^5^^^^^^^ ^6 7^^^^^^^^^^^^^^^^^

eg for Abricate_resfinder_combined.csv  ie the long version
AA_CKDN230030154-1A_HGKHYDSX7_L2.fasta/assembly.fasta
2 ^^^^3^^^^^^^^ 4^ ^5^^^^^^^ ^6 7^^^^^^^^^^^^^^^^^

```{r define_join_key}

# summary, ie wide version of abricate resfinder result
resfind_sum_pct_df = resfind_sum_pct_df %>%
  #                                                2                 3                    4                  5                      6              7=DB specific
  mutate( sample_name     = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_resfinder).tsv"  )[,2] )%>%
  mutate( Hnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_resfinder).tsv"  )[,5] )%>%
  mutate( Lnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_resfinder).tsv"  )[,6] )%>%
  mutate( key    = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) )

# AB is not unique, ditt for AD, maybe others.

# long version of abricate resfinder result, ie 1 gene per row
resfind_long_pct_df = resfind_long_pct_df %>%
  #                                                2                 3                    4                  5                      6            "7"=DB specific
  mutate( sample_name     = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta/assembly.fasta"  )[,2] )%>%
  mutate( Hnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta/assembly.fasta"  )[,5] )%>%
  mutate( Lnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta/assembly.fasta"  )[,6] )%>%
  mutate( key    = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) )


##XX vfdb_tsv_df = vfdb_tsv %>%
vfdb_sum_pct_df = vfdb_sum_pct_df %>%
  #                                                2                 3                    4                  5                      6              7=DB specific
  mutate( sample_name     = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_vfdb).tsv"  )[,2] )%>%
  mutate( Hnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_vfdb).tsv"  )[,5] )%>%
  mutate( Lnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_vfdb).tsv"  )[,6] )%>%
  mutate( key    = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) )

# AA_CKDN230030154-1A_HGKHYDSX7_L2_Abricate_ecoli_vf.tsv
ecvf_sum_pct_df = ecvf_sum_pct_df %>%
  #                                                2                 3                    4                  5                      6              7=DB specific
  mutate( sample_name     = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_ecoli_vf).tsv"  )[,2] )%>%
  mutate( Hnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_ecoli_vf).tsv"  )[,5] )%>%
  mutate( Lnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)\\_(Abricate_ecoli_vf).tsv"  )[,6] )%>%
  mutate( key    = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) )

# View( ecvf_sum_pct_df )

mlst_tsv_df = mlst_tsv %>%
  #                                                2                 3                    4                  5                      6              
  mutate( sample_name     = str_match( Filename, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta"  )[,2] )%>%
  mutate( Hnum            = str_match( Filename, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta"  )[,5] )%>%
  mutate( Lnum            = str_match( Filename, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+).fasta"  )[,6] )%>%
  mutate( key    = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) )
  
  



```

########################################################

# parse Tilden's file, create join key, so can extract metadata.



filename eg for ResMlstCombTable50 MLST Results/Sample Info Added_mlst.all  https://docs.google.com/spreadsheets/d/1H52g-yjbIhMBgJjknIDR7McCPlxu2OI72Pn0JZtH8gY/edit?usp=drive_link 
AA_CKDN230030154-1A_HGKHYDSX7_L2.fasta
 I_CKDN230030142-1A_HGKHYDSX7_L2_Abricate_resfinder.tsv
^2 ^^^^3^^^^^^^^ 4^ ^5^^^^^^^ ^6 7^^^^^^^^^^^^^^^^^
||                              |||||||||||||||||||
why are 27 rows  filenames end with ".fasta",  rest have the "Abricate_resfinder.tsv" ??   ++CHECK++


```{r TildenCreateJoinKey}


#  define_join_key

ResMlstCombTable50 = ResMlstCombTable50 %>%
  #                                                2                 3                    4                  5                      6            
  mutate( sample_name     = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)"  )[,2] )%>%
  mutate( Hnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)"  )[,5] )%>%
  mutate( Lnum            = str_match( file_name, "([:alpha:]+)[\\-_](CKDN[:digit:]+)[\\-]([:alnum:]+)[\\-_]H([:alnum:]+)DSX7[\\-_]L([:alnum:]+)"  )[,6] )%>%
  mutate( key  = str_c( sample_name, "_H", Hnum, "_L", Lnum,  sep="" ) ) %>%
  mutate( ctrl = "ResMlstCombTable50" )

# colnames( ResMlstCombTable50 )

sample_metadata = ResMlstCombTable50 %>%
  dplyr::select( date, site, source, SDE, file_name, sample_name, key, Hnum, Lnum, ctrl ) %>%
  rename( `Sampling_Loc` = SDE )

# View( sample_metadata )

# saving this to metadata/  
# both for discussion, as well as easier future fetch of metadata for this dataset

write_tsv( sample_metadata, "metadata/sample_metadata.tsv" ) 

#ResMlstCombTable50

```


########################################################


# join mlst with resfinder result & vfdb 

```{r join}


# sample_metadata
# sample_metadata_withDupInfo # manually edited to contain duplicate info

mlst_resfind_df = full_join(
  x  = mlst_tsv_df, 
  y  = resfind_sum_pct_df,
  by = "key"
  #by = c( 'Filename' = "file_name")  # nope, these filenames are not matching!  need to define a key for them.
)

#View( mlst_resfind_df )



# only used in sanity check, not any analysis for current MDPI paper in 2024
mlst_resfind_vfdb_df = full_join(
  x  = mlst_resfind_df, 
  y  = vfdb_sum_pct_df,
  by = "key"
)

mlst_resfind_vfdb_ecvf_df = full_join(
  x  = mlst_resfind_vfdb_df,
  y  = ecvf_sum_pct_df, 
  by = "key"
)

# View( mlst_resfind_vfdb_ecvf_df )

```


# condensed tmp result, write result, this is temporarily, so can look at it using spreadsheet, for discussion

noded filenames with dup sample id
AB
AD
AH
AS
AY
BB - 6 rows... dups?
I has NA cuz the Hnum is from table w/o the ST info


```{r write_tsv}

## these were for discussion, probably no longer needed

#condense_mlst_resfind_df = mlst_resfind_df %>%  
#  select( sample_name.y, Hnum.x, Lnum.x, key, Filename, PubMLST_scheme_name, SeqType, RESIST_NUM_FOUND  ) 

#write_tsv( condense_mlst_resfind_df, "result/condense_mlst_restfind_df.tsv")
#write_tsv(          mlst_resfind_df, "result/mlst_restfind_df.tsv")

#View( condense_mlst_resfind_df )

```





############################################
############################################


# new result, ie version 2
start from my table, 
only pull meta data from Tilden
expect about 50 rows
see if there are dups that may want to trim down to ~44.

```{r resultV2 }


#newResut = TinVsTilden %>%
#  select( Filename, key, sample_name.x.x, SeqType, SeqType.x, SeqType.y,  ctrl.x, ctrl.y, RESIST_NUM_FOUND, NUM_FOUND, Species, source, `SDE`   )


resultV2_raw = left_join(
  #x  = sample_metadata, 
  x  = sample_metadata_withDupInfo, 
  y  = mlst_resfind_vfdb_ecvf_df,    # Tin's result, alt? mlst_resfind_vfdb_ecvf_df  mlst_resfind_df
  by = "key"
) 
# 50 raw records
# 49 after dropping sample "I" which has no fasta file

resultV2_wSpecieName_raw = right_join(
  x  = specieName,
  y  = resultV2_raw, 
  by = "PubMLST_scheme_name" 
)


resultV2 = resultV2_wSpecieName_raw %>%
  drop_na( Filename ) %>% 
  filter( is.na( DuplicateInfo ) )   # I will have to remember not to put any info in rows that isn't a dup :D

# %>%   select( -Hnum, -Lnum )
  
# full_join would get 56 rows, 6 of them have no sample metadata info
# left_join would get 50 rows, dropping those rows without sample metadata info (which are the Dup samples )


#  select( key, ctrl,  Allele_ID_1, Allele_ID_2, Allele_ID_3, Allele_ID_4, Allele_ID_5, Allele_ID_6, Allele_ID_7,  sample_name, Hnum, Lnum,  )
  
  
  
# after done, then maybe join with previuos compare table and see differences...
#  select( Filename, key, sample_name.x.x, sample_name.y.y, SeqType, SeqType.x, SeqType.y,  ctrl.x, ctrl.y, site, `FARM TYPE`, source, `SAMPLE TYPE`, SDE, `SAMPLING LOCATION`, file_name.x, Species,  Order.x, Order.y, RESIST_NUM_FOUND, NUM_FOUND  )
#  select( key, sample_name.x.x, sample_name.y.y, RESIST_NUM_FOUND, NUM_FOUND, Species,  Order.x, Order.y ,  ctrl.x, ctrl.y, site, `FARM TYPE`, source, `SAMPLE TYPE`, SDE, `SAMPLING LOCATION`, Filename, file_name.x )
  




```


# sanity check

9 rows have NA for Allele_ID_*   did abricate run correctly on these?   
the resfinder have '-' and thus treated as RESIST_NUM_FOUND=0.

I  : nothing for this as no fasta seq was generated by unicycler
L  : mlst didn't crash, it did just output "- -", seems like normal output when nothing found.
     abricate has output for vfdb, nothing for ecoli and resfinder, so seems to be working correctly
 
BD BC  AW AN AL AE : These have NUM_VFDB_FOUND > 1
AK : NUM_VFDB_FOUND=0 ... 
      no ecoli_vf either.  but unicycler has no error for this, generated a 12M fasta file, it is on the large side, but seems ok.  not likely to have any problem with the seq. 
      Assembly complete (2023-11-15 00:34:10)
      ---------------------------------------
      Saving /global/scratch/users/tin/fc_graham/ecuador_2023_TJ/Sequences/Tilden/ALL/assembled-sequences_par3/AK_CKDN230030164-1A_HGKHYDSX7_L2.fasta/assembly.gfa
      Saving /global/scratch/users/tin/fc_graham/ecuador_2023_TJ/Sequences/Tilden/ALL/assembled-sequences_par3/AK_CKDN230030164-1A_HGKHYDSX7_L2.fasta/assembly.fasta

AZ D prob fine, has some Allele_ID info.


# dup check, notes

Niko said that sample with same ST and resistance could be duplicate.
I am going to use the MLST + resfind + vfdb to check for this.
the condensed versino might or might not be enough...

observations:
Sample have matching  ST, RESIST_NUM_FOUND, VFDB_NUM_FOUND.    hmm... add the ecoli_vf result?
- ST15:   AF A P Q            # still match with ECVF   # TR had 4 records: AF A L P 
- ST155:  AA AR               # diff num of ECVF resistance gene, so unlikely to be dup?
- ST6186: AB AG AT AY H K     # still match with ECVF



```{r check_for_dup, eval=F }
# View( mlst_resfind_vfdb_df )
# View( mlst_resfind_vfdb_ecvf_df )

# strip most of the col with VFDB genes.
mlst_resfind_vfdb_df_condensed = mlst_resfind_vfdb_df %>% # prev: mlst_resfind_vfdb_df %>%
  dplyr::select( 1:16, 77:83, 405:408 )


# View( mlst_resfind_vfdb_df_condensed )

#XX mlst_resfind_vfdb_df_checkDup = mlst_resfind_vfdb_df %>%
#XX  select( Filename, PubMLST_scheme_name, SeqType, RESIST_NUM_FOUND, VFDB_NUM_FOUND, sample_name, Hnum, Lnum )

# View( mlst_resfind_vfdb_df_checkDup )

resultV2_raw_checkDup = resultV2_raw %>%  # resultV2 has "I" sample removed as it has NA due to lack of fasta
  dplyr::select( Filename, source, Sampling_Loc, site, date, PubMLST_scheme_name, sample_name.x, SeqType, RESIST_NUM_FOUND, VFDB_NUM_FOUND, ECVF_NUM_FOUND,  Hnum.x, Lnum.x )


print( "check these as duplicates?  done." )                    
resultV2_raw_checkDup %>% filter( SeqType=="15")
resultV2_raw_checkDup %>% filter( SeqType=="6186")

# View( mlst_resfind_vfdb_ecvf_df_checkDup )

# eventually ran cgMLST via web and wrote a new sample_metadata_withDupInfo  with duplicate info.


resultV2_raw_checkDup %>% head(5)
```

############################################


```{r moreExtensiveCheckToEnsureDup}

# see that these 2 groups or samples contain duplicates

# View( mlst_resfind_vfdb_ecvf_df )



mlst_resfind_vfdb_ecvf_df %>% filter( SeqType=="15")

# Niko suggested that for abricate output of VFDB and ECVF , 
# check NUMFOUND and also check that they are the same genes that matched.

# t() is a transpose fn that convert rows into columns.  works out better than pivot_longer() in this case

ST15_long = mlst_resfind_vfdb_ecvf_df %>% 
  filter( SeqType=="15")  %>%  
  mutate( RESIST_NUM_FOUND = as.character( RESIST_NUM_FOUND ),
          VFDB_NUM_FOUND   = as.character( VFDB_NUM_FOUND   ), 
          ECVF_NUM_FOUND   = as.character( ECVF_NUM_FOUND   ) 
          ) %>%
  pivot_longer( cols = everything() )



ST15_long = as.data.frame( 
  t( mlst_resfind_vfdb_ecvf_df  %>% filter( SeqType=="15") )
) %>% 
  mutate(  Flag = 
             case_when( 
               V1 != V2  ~ "V1 != V2" , 
               V1 != V2  ~ "V2 != V3" , 
               V1 != V3  ~ "V1 != V3"   
           )
) %>% filter ( !is.na(Flag) )

# View( ST15_long )
ST15_long



mlst_resfind_vfdb_ecvf_df %>% filter( SeqType=="6186")


ST6186_long = as.data.frame( 
  t( mlst_resfind_vfdb_ecvf_df  %>% 
       filter( SeqType=="6186", 
               str_detect( key, "AG_|AT_|K_")
       )
     )
) %>% 
  mutate(  Flag = 
             case_when( 
               V1 != V2  ~ "V1 != V2" , 
               V1 != V2  ~ "V2 != V3" , 
               V1 != V3  ~ "V1 != V3"   
           )
) %>% filter ( !is.na(Flag) )


# okay, so all actual genes match in addition to the NUM_FOUND.

ST6186_long
# View( ST6186_long )


# sanity check that my process works.  it does, here limited to 3 seq comparison

STtest_long = as.data.frame( 
  t( mlst_resfind_vfdb_ecvf_df  %>% 
       filter( SeqType=="6186", 
               str_detect( key, "BB_HGKHY_L2|H_|K_")
       )
     )
) %>% 
  mutate(  Flag = 
             case_when( 
               V1 != V2  ~ "V1 != V2" , 
               V1 != V2  ~ "V2 != V3" , 
               V1 != V3  ~ "V1 != V3"   
           )
) %>% filter ( !is.na(Flag) )


# View( STtest_long )
STtest_long %>% head(5)

# 
#mutate(across(everything(), as.character)) %>%




```

############################################
############################################
############################################

# data analysis 

analysis part is where need to be sure DF has duplicate removed.
# eventually ran cgMLST via web and wrote a new sample_metadata_withDupInfo  with duplicate info.

resultV2 does use sample_metadata_withDupInfo and filtered out duplicate rows.
should be 44 samples for analysis.


```{r pre_data_analysis_checkNumOfSample}

# count number of Water vs Shrimp

resultV2sampleSum = resultV2 %>% group_by( source ) %>%
  summarize( count = n() )
resultV2sampleSum


num_Shrimp_Sample = resultV2sampleSum %>% filter( source=="SHRIMP" ) %>% pull( count )
num_Water_Sample  = resultV2sampleSum %>% filter( source=="WATER"  ) %>% pull( count )  

#XX num_Sample = resultV2sampleSum
num_Sample = as.data.frame( resultV2sampleSum )    # force df, in case resultV2sampleSum is a tibble, which wont work for row.names below

# num_Sample         # as 2x2 DF

# num_Sample[,1]

# alt syntax, same result
num_Shrimp_Sample = num_Sample[num_Sample$source=="SHRIMP",]$"count"   # scalar
num_Water_Sample  = num_Sample[num_Sample$source=="WATER" ,]$"count"


# assign name to row:
row.names(num_Sample) = num_Sample[,1]

num_Sample["SHRIMP", "count"] # use rowname to fetch value
num_Sample["WATER",  "count"] # use rowname to fetch value

num_Shrimp_Sample  # 13  # 13 still after dropping duplicates
num_Water_Sample   # 36  # 31 after dropping duplicates           ...  so 44 samples at the end of all duplicate removal in analysis v2.
# these are scalar values



totalNumSample = num_Sample %>%
  pull( count ) %>%
  sum()
totalNumSample # 44  

```

## amrClassification
based on p4 of https://docs.google.com/document/d/1Rabm0hkc8KGJsu436EjfbLrXRW7ExY7WvxGv24w_FAY/edit 

```{r amrClassification}

#resfinder_labeled = full_join(
resfinder_labeled = right_join(
  #x  = sample_metadata,
  x  = sample_metadata_withDupInfo,
  y  = resfind_long_pct_df,
  by = "sample_name"
  #by = "key"
)

# full_join  by key would show that 13 samples did not have resfinder results (total 238 rows)   AC AE AK AL AN AW AZ BC BD D F I L
# right_join by key  (225 rows)  but no sample info for    AB AD AH AS AY BB
# right_join by sample_name (rather than key) result in 225 rows.
# use right join so not have to worry about doing drop NA, since not all fasta has resistence gene found (% will have to be calc from total num of samples, data outside this table)

resfinder_labeled = resfinder_labeled %>%
  mutate( checkFastaFilename = case_when( 
      ( key.x != key.y )  ~ "check"
  ) ) %>%
  mutate( checkHnum = case_when( 
      ( Hnum.x != Hnum.y )  ~ "check"
  ) ) %>%
  mutate( checkLnum = case_when( 
      ( Lnum.x != Lnum.y )  ~ "check"
  ) )
# filename, Hnum, Lnum, flagged consistently.  
# assuming multiple fasta for same Sample yield same result, then this is okay
# metadata extracted from TR's file may not have cared the nuanced of multiple fasta for same sample? ++CHECK++


# 15 rows is flagged, for samples AB AD AH AS AY BB

# ampH is not beta-lactam?  ++check++ 
# cmlA1, floR/floR_2 should be classified as Chloramphenicol  ++


# 9 classes of AMR defined by TR,  reused code.

resfinder_labeled <- resfinder_labeled %>%
  mutate(amr_type = case_when(
    
    # Beta-lactams: Updated to include various beta-lactamase types and previously "Other" categorized genes
    str_detect(gene, "ampH") |                                   # TR Fig4 include ampH, I think it should be added here as well.
    str_detect(gene, "blaKPC") | str_detect(gene, "blaOXA") | 
    str_detect(gene, "NDM") | str_detect(gene, "CTX") | 
    str_detect(gene, "SHV") | str_detect(gene, "CMY") | 
    str_detect(gene, "TEM") | str_detect(gene, "cphA1") | 
    str_detect(gene, "cphA2") | str_detect(gene, "blaACT-6") |
    str_detect(gene, "blaCMY.8b|blaCMY.2|blaCMY.98") | 
    str_detect(gene, "blaACT.6") | str_detect(gene, "blaCTX.M.[0-9]+") | 
    str_detect(gene, "blaOXA.[0-9]+") | str_detect(gene, "blaSHV.[0-9]+") | 
    str_detect(gene, "blaTEM.1B") | str_detect(gene, "blaCMH.3") | 
    str_detect(gene, "blaPAO") | str_detect(gene, "blaSED1") ~ "Beta-lactams",
    
    # Quinolones
    str_detect(gene, "qnr") | str_detect(gene, "oqx") | 
    str_detect(gene, "oqxA|oqxB") | str_detect(gene, "qnrB69|qnrS1|qnrB1") ~ "Quinolones",


    # Aminoglycosides
    str_detect(gene, "aac") | str_detect(gene, "aph") | 
    str_detect(gene, "ant") | str_detect(gene, "aad") ~ "Aminoglycosides",


    # Macrolides
    str_detect(gene, "mdf") |    # TR Fig 4 include mdf.A here, 28 rows.    ## TR used "mdf.A"
    str_detect(gene, "erm") | str_detect(gene, "mph") ~ "Macrolides",


    # Sulfonamides
    str_detect(gene, "sul") ~ "Sulfonamides",


    # Trimethoprim
    str_detect(gene, "dfr") ~ "Trimethoprim",


    # Tetracyclines
    str_detect(gene, "tet") ~ "Tetracyclines",


    # Fosfomycin
    str_detect(gene, "fos") ~ "Fosfomycin",


    # Colistin
    str_detect(gene, "mcr") ~ "Colistin",


    # Chloramphenicol
    str_detect(gene, "floR")  |  # TR Fig 4 include floR, gene maybe listed specifically as floR_2
    str_detect(gene, "cmlA1") |  # in TR Fig 4 as well
    str_detect(gene, "catB7") ~ "Chloramphenicol",
    
    # Default to "Other" if none of the above conditions are met
    TRUE ~ "Other"      # nothing felt as "Other" after using all genes listed in Fig4.
  ))


resfinder_labeled_noDup = resfinder_labeled %>%
  filter( is.na( DuplicateInfo ) )   # I will have to remember not to put any info in rows that isn't a dup :D

```

####
#### gene centric view
####

# generate table for Fig2

```{r tabForFig2 }


# calculate percentage of each class of AMR
# (% will have to be calc from total num of samples, data outside resfinder_labeled table, use resultV2sampleSum )
# 
# num_Shrimp_Sample  # 13   # from resultV2sampleSum
# num_Water_Sample   # 36
# num_Sample["SHRIMP", "count"] # use rowname to fetch value
# sampleName = "SHRIMP"
# num_Sample[ sampleName, "count"] # use rowname to fetch value


#resAmrCountBySample = resfinder_labeled %>% 
resAmrCountBySample = resfinder_labeled_noDup %>%
  #group_by( amr_type, source )  %>%
  group_by( amr_type, source, sample_name )  %>%
  summarize( amrCatCount = n() ) 
  
resAmrCountByCategory = resAmrCountBySample %>%
  group_by( amr_type, source )  %>%
  summarize( count = n() )      %>%
  mutate( grpTotal =          num_Sample[source,"count"] )  %>% 
  mutate( percentage =  count/num_Sample[source,"count"]*100)

#  mutate( TESTing = num_Sample["SHRIMP","count"]) %>%
  
View( resAmrCountByCategory )

resAmrCountByCategorySanOther = resAmrCountByCategory %>%
  filter( amr_type != "Other")
# TR Fig2 didn't plot the "Other" category
# There is no "Other" left after adding the genes in Fig 4 not previously in code from p4 of the word doc.

#resAmrCountByCategory
resAmrCountByCategorySanOther

resAmrCountByCategory %>%  filter( amr_type == "Other")
## okay, good,  "other" has 0 row, all amr_type have been classified

```

# variuos stat for result overview section of paper 

```{r stat4paper}
# aid to help write manuscript.
# count number of samples 

#ARGbySample = 

totalNumARG = resAmrCountByCategory %>% 
  pull( count ) %>% 
  sum( )
totalNumARG


totalNumSample  # calculated higher up

#// avgNumArgPerSample = totalNumARG / totalNumSample 
#// avg here is 2.5
#// this is wrong stat, this is by class of amr_type
#// need to be more sample specific, so use number below.

## summary( resAmrCountByCategory )  # not the stat needed here

# View( resultV2 )

numResGeneBySample = resultV2 %>% select( sample_name, RESIST_NUM_FOUND )
summary( numResGeneBySample )

# mean, median are 3.5 and 2.

View( resAmrCountByCategory )  # this is actually number of samples per amr_type 

#XX SampleWith2plusArg = resAmrCountByCategory %>%  ## is this the right df to use? ++
#xx  filter( amrCatCount > 1 ) # %>% 
#xx   group_by( sample_name )
  
View( resfinder_labeled_noDup )




# spot chec
resfinder_labeled_noDup %>% filter( gene == "ampH_2") %>% pull(key.x, Hnum.x )

# checking procedure...   get sample and their genes first, easier to check

amrListPerSample = 
  resfinder_labeled_noDup %>% 
  group_by( sample_name, gene )  %>% 
  #group_by( sample_name ) %>%
  summarize( count=n() )    # %>% filter( sample_name == "K" )  # spot check

amrCountPerSample = amrListPerSample %>% 
  group_by( sample_name ) %>% 
  summarize( count=n() ) 

View( amrCountPerSample )



amrClassListPerSample = 
  resfinder_labeled_noDup %>% 
  group_by( sample_name, amr_type )  %>% 
  #group_by( sample_name ) %>%
  summarize( count=n() )   # %>% filter( sample_name == "K" )

amrCountPerSample = amrClassListPerSample %>% 
  group_by( sample_name ) %>% 
  summarize( count=n() )  %>%   # 32 rows without filter
  filter( count > 1 )     #       26 rows with filter   
# View( amrCountPerSample )  # 
print( n=50, amrCountPerSample )               # even console output limit num of rows it output, at least in Rstudio.        
#########
#########   amrCountPerSample  I am confident.
#########   26 samples w/ 2 or more amr_type.     
#########

26/44
# 59% of sample has 2 or more amr class 

```
# generate plot for Fig2
```{r plotForFig2 }


# 1. geom_bar(aes(col = var), stat = "identity", position = "dodge")

# after categorizing all amr_type, 
# resAmrCountByCategorySanOther is same as resAmrCountByCategory

#fig2 = 
ggplot( data = resAmrCountByCategorySanOther, 
        #mapping=aes( x=amr_type, y=percentage, fill=source )         # not sure orderning, not per case_when above
        mapping=aes( x=forcats::fct_reorder(amr_type,desc(percentage)), y=percentage, fill=source )   # sort
      ) +
  #geom_bar( stat="identity", position="dodge2" )  +
  geom_col( position=position_dodge2(preserve="single", width=0.9)) + 
  labs( x="Antibiotic class", 
        y="% of isolates positive for antibiotic resistance genes"  #, 
        #title="Fig 2, will remove floating numbers for final version, they are here for discussion use"
        ) + 
  #geom_text( aes(label=round(percentage,0) ) )  +
  theme( axis.text.x = element_text(angle=20, vjust=0.9, hjust=1) ) 


# dodge2
# https://stackoverflow.com/questions/38101512/the-same-width-of-the-bars-in-geom-barposition-dodge 

# if want similar graph as before, might have to export table to excel and plot from there?


#fig2


```

# generate table for Fig4  
(Fig 3 code below, Fig 4 is closer to Fig 2)



```{r tabForFig4}

# may not need new table, just way to generate plot with sub categories... 
# Actually, looks like need to create counts per group/categories...

# AMR = Antibiotic Resistance Gene  (no distinction b/w AMR vs ABR)

# resAmrCountBySample %>% 
#resAmrCountByGene = resfinder_labeled %>%
resAmrCountByGene = resfinder_labeled_noDup %>%
  group_by( amr_type, gene, source  ) %>%      # use gene instead of PRODUCT
  summarize( AMR_Count = n() )  
  #%>%  # rename( AMR = gene )                   #-- %>% filter ( AbrGene == "mdf(A)" )   
write_tsv( resAmrCountByGene, "TMP/resAmrCountByGene.TSV" )

# View( resAmrCountByGene )

# reviewer #1 say to use Abr , thus named as AbrGene  ++CHECK++

# update ABR gene count



```
# statForManuscriptFig4
around line 160 of manuscript


```{r pre_statForFig4__troubleshooting}

# these are my debbuging/troubleshooting, till arrive to the workaround with pivot_wider.  

# number of unique ARG found
amr_gene_list = as.data.frame( resAmrCountByGene ) %>% select ( gene, source )  
amr_gene_list %>% 
  count()
# 71
amr_gene_list %>% group_by( gene ) %>% count() %>% filter( n > 1 )  # 10 genes have multiple source, thus the extra rows

# but I purposefully dropped source, why does it remain?? 
# amr_gene_list %>% write_tsv( "TMP/amr_gene_list.TSV" )

amr_gene_list_unique = as.data.frame( resAmrCountByGene ) %>% select ( gene, -source ) %>%  
  unique( ) 
amr_gene_list_unique %>%
  count()
# 61
# amr_gene_list_unique %>% write_tsv( "TMP/amr_gene_list_unique.TSV" )

amr_gene_list_unique %>% group_by( gene ) %>% count() %>% filter( n > 1 )  # 0 , the unique() was what dropped the 10 rows due to differing source.
amr_gene_list_unique %>% group_by( gene ) %>% count() %>% nrow()   # 61
```

```{r statForManuscriptFig4, eval=T}

# don't know what the tibble source col persist and wrecking my gene count per amr_type wrong.  pivot wider just to circumvent the problem! (is this an R bug?  or some strange tibble thing that I didn't catch?)
resAmrCountByGene_wide = resAmrCountByGene %>%
  pivot_wider( names_from = source, values_from = AMR_Count ) %>%
  replace_na( list( WATER = 0, SHRIMP = 0 ) ) %>%  # replace NA with 0, so can sum them up 
  mutate( sampleCount = WATER + SHRIMP )

nrow( resAmrCountByGene_wide ) # 61!!  good, no extra rows due to source
# View( resAmrCountByGene_wide )   # this has detail of each gene

# Sn_tmpFig4 = 
genes_of_amrClass = 
resAmrCountByGene_wide %>% 
  select( amr_type, gene )  %>%
  group_by ( amr_type ) #%>% 

nrow( genes_of_amrClass ) # 61


geneCount_by_amrClass = 
  genes_of_amrClass %>%  summarize( counter = n() ) #count() %>% pull(n)
sum( geneCount_by_amrClass$counter ) # 61.  finally correct!

View( geneCount_by_amrClass )
```

```{r count_blatCTX-M}

# View( resAmrCountByGene_wide )   # this has detail of each gene

resAmrCountByGene_wide %>% filter( str_detect( gene,  "blaCTX-M-15" ) )   # 2+1 Water+Shrimp

resAmrCountByGene_wide %>% filter( str_detect( gene,  "blaCTX" ) )   

resAmrCountByGene_wide %>% filter( str_detect( gene,  "blaCTX" ) )  %>%
  summarize( sum( sampleCount ) )  #  2+1 Water+Shrimp

sum( 
  ( resAmrCountByGene_wide %>% filter( str_detect( gene,  "blaCTX" ) ) )$sampleCount 
  )  # 18


resAmrCountByGene_wide %>% filter( str_detect( gene,  "oqx" ) )  %>%
  summarize( sum( sampleCount ) )  #  2+1 Water+Shrimp


```

```{r theseProbNotNeededAnymore, eval=F }


geneCount_by_amrClass_DF = 
as.data.frame( genes_of_amrClass )  %>% summarize( counter = n() ) #count() %>% pull(n)
# same result, still 71!!

# %>% select( counter )

geneCount_by_amrClass = genes_of_amrClass  %>% group_by( amr_type ) %>% 
  summarize( geneCount = n() )

#geneCount_by_amrClass = as.data.frame( genes_of_amrClass )  %>% group_by( amr_type ) %>% 
#  summarize( geneCount = tally() )

#0727 resume here

# geneCount_by_amrClass 
  
# create a df of amr_type and number of gene found for each amr_type

genesPerAmrType = resAmrCountByGene %>% 
  group_by( amr_type ) %>%
  summarize( numOfGene = n() )  




  #select %>% count() %>% pull(n)
# 9 classes

Sn_tmpFig4AdderU = Sn_tmpFig4  %>% unique() %>% count()
sum( Sn_tmpFig4AdderU$n ) # 61

Sn_tmpFig4Adder = Sn_tmpFig4  %>%  count()
sum( Sn_tmpFig4Adder$n ) # 71


%>% sum(n)
as.data.frame( Sn_tmpFig4 ) %>% unique() %>% count()  # 61

#Sn_numero4 = 
resAmrCountByGene %>% 
  select( amr_type, gene ) %>%
  group_by ( amr_type ) %>%                     # the gruop_by is likely tieing source and causing count to go up!
  summarize( numOfGene = n())  %>%    
  #pull( numOfGene )
  summarize( totalNumOfGene = sum(numOfGene) )
# get 71 genes this way.


Sn_tmpFig4  
  
# number of amr_type found
as.data.frame( resAmrCountByGene ) %>% select ( amr_type )  %>% 
  unique() %>% 
  count()
# 9, match expectation
# needed as.data.frame, the tibble forced a grouping with gene!


```

```{r eval=F}
####++ ponder again... TR used PRODUCT in Fig4.  Just treated it as gene, collapsing the _1 _2 version of eg tetB_1 tetB_2.

# dont use PRODUCT, here is to highlight the diff vs "gene"

resAmrCountByPRODUCT = resfinder_labeled_noDup %>%
  group_by( amr_type, PRODUCT, source  ) %>%      # just to check, here using  PRODUCT instead of gene
  summarize( AbrGenePRODUCT_Count = n() )  %>% 
  rename( AbrGenePRODUCT = PRODUCT )                   #-- %>% filter ( AbrGene == "mdf(A)" )
write_tsv( resAmrCountByPRODUCT, "TMP/resAmrCountByPRODUCT.TSV" )
# unix diff these two files.
# there are more rows in the "gene" version but should use that, since paper talks about gene, not the resulting PRODUCT (protein)

## TR fig4 used PRODUCT instead of gene ... 

```

# generate bar chart for Fig4

```{r barGraphForFig4_noGood }

# almostExactProblem found in 
# https://stackoverflow.com/questions/15887461/remove-empty-factors-from-clustered-bargraph-in-ggplot2-with-multiple-facets

fig4axisLabel = c("xx", "yy")

# ++ consider try to put the legend inside the plot area, so it doesn't take up space on the right side.

fig4 = resAmrCountByGene %>% 
  ggplot( aes(x = factor(gene), y = AMR_Count))

fig4 = fig4 + 
  facet_grid( amr_type ~ . , 
              switch = "y",
              shrink = F,
              margins = fig4axisLabel,  # ??  def=F
              axis.labels="all_x",
              scales="free_y",
              space="free") +    # space="free" allowed subpanels to be different size
  geom_bar(stat="identity", 
           aes(fill=factor(resAmrCountByGene$source)),      
           position="stack")  +                              # dodge = double width bar for single categories.
  theme_bw() + 
  theme( axis.text.x=element_text( angle=0 ),
         axis.text.y=element_text( angle=0),
         strip.text.x.top = element_text(angle = 0),
         strip.text.y.left = element_text(angle = 0)
         ) +   
  #geom_text( aes(label=round(AMR_Count,0) ) )  +   # tmp label the column "height"
  labs( y="Number of antibiotic resistance genes by antibiotic class",
        x="",
        #title="Fig 4, will remove floating numbers for final version, they are here for discussion use", 
        fill = "Source"  # legend title!
) +
  coord_flip()    


fig4




# ggsave("TMP/fig4.tiff", fig4 )
# ++ I have not figure out how to place the ABR categories to the left of the ABR genes, if you know or have pointer, please post!  (I am using facet_grid and geom_bar)
# hmm... is it setting margin space?
# maybe gimp if need to swap orders of class vs ARG.
```

####
#### species centric data reporting 
####

# generate table for Fig3

use PubMLST_cheme_name for organism

```{r tabForFig3}

totalNumOfSample = nrow( resultV2 )  
totalNumOfSample   # 44  yes, this is the number in analysis v2.  2024.0725

bacteriaDistribution = resultV2 %>% group_by( PubMLST_scheme_name ) %>%
  summarize( specieCount = n() ) %>%
  mutate( speciePercent = specieCount/totalNumOfSample*100 ) 

# bacteriaDistribution

# specieName added to resultV2 above, but after summarize lost the info
bacteriaDistributionWithSpecieName = right_join(
  x  = specieName,
  y  = bacteriaDistribution, 
  by = "PubMLST_scheme_name" 
)

bacteriaDistributionWithSpecieName = bacteriaDistributionWithSpecieName %>%
  mutate( percent_label       = paste0( round( speciePercent, 0 ), "%" ) ,
          specie_legend_label = paste0( Specie_Name, " (n=", specieCount, ")" ) )

bacteriaDistributionWithSpecieName

```

# generate plot for Fig3



```{r fig3}

#resultV2
# pie( bacteriaDistributionWithSpecieName$speciePercent )

# italic text in legend: https://stackoverflow.com/questions/59554096/ggplot2-italics-in-the-legend 
#library(ggtext)  # remotes::install_github("clauswilke/ggtext")
## p_load(ggtext) # failed to install on zyzyxia3
# install.packages( "pak" )
# library(pak)
# pak::pak( "ggtext" ). # seems like failing on zyzyxia3 as well.  on a dep png


# https://r-charts.com/part-whole/pie-chart-ggplot2/
# A pie chart in ggplot is a bar plot plus a polar coordinate. 
# You can use geom_bar or geom_col and theta = "y" inside coord_polar.

#fig3 = 
bacteriaDistributionWithSpecieName %>% 
  ggplot( aes( x="", fill=specie_legend_label, y=speciePercent )) + 
  geom_col() + 
  geom_col(color = "black") +
  geom_text(aes(label = percent_label ),
            color="black",
            position = position_stack(vjust = 0.5)) +
  coord_polar( theta="y" ) + 
  labs( fill="Species" ) +     # strange way to set text for the legend title
  theme_void() + 
  #theme( legend.text = element_markdown() )
  theme( legend.text = element_markdown(face = "italic")  )

  #theme( legend.text = element_markdown(face = c("plain", "italic")) )           # there were some way to do some plain, some italic, by specifying each one... 
  #theme( legend.text = element_markdown(face = c("plain", rep("italic", 7))) )

# italic text in legend: https://stackoverflow.com/questions/59554096/ggplot2-italics-in-the-legend 

#fig3

```

```{r TildenPieChart, eval=F}


library(RColorBrewer)

# Assuming 'X.FILE' is your column of interest for counting unique values within each species
##species_counts <- filtered_data %>%
##    group_by(Species) %>%
##    summarise(species_count = n())

# Generate a more subdued color palette
color_palette <- brewer.pal(min(8, length( bacteriaDistributionWithSpecieName$Specie_Name )), "Pastel1")

if (length( bacteriaDistributionWithSpecieName$Specie_Name  ) > 8) {
  color_palette <- colorRampPalette(brewer.pal(8, "Pastel1"))(length( bacteriaDistributionWithSpecieName$Specie_Name ))
}



# Plot the pie chart without labels
#pie(species_counts$species_count, labels = NA, 
#    col = color_palette, main = "Breakdown of Organisms Identified", cex = 1.2)

pie( bacteriaDistributionWithSpecieName$speciePercent, labels=NA, 
    col = color_palette, main = "Breakdown of Organisms Identified", cex = 1.2)


# Initialize the y position for the first legend item
y_init <- 1.0

# Define the step to decrease the y position for each subsequent legend item
# y_step <- 1.0 / length( species_counts$Species )
y_step <- 1.0 / length( bacteriaDistributionWithSpecieName$Specie_Name )

# Manually add each legend item
#for (i in seq_along(species_counts$Species)) {
for (i in seq_along( bacteriaDistributionWithSpecieName$Specie_Name )) {
  species_parts <- unlist(strsplit( bacteriaDistributionWithSpecieName$Specie_Name[i] , " "))
  y_pos <- y_init - (i - 1) * y_step  # Calculate the y position for the current item
   
  # Construct the legend text with the correct n= value
  #legend_text <- if (length(species_parts) > 1 && tolower(species_parts[2]) != "spp.") {
  legend_text <- if (length(species_parts) > 1 && tolower(species_parts[2]) != "spp.") {
    bquote(italic(.(species_parts[1])) ~ italic(.(species_parts[2])) ~ "-" ~ .(bacteriaDistributionWithSpecieName$speciePercent[i]) ~ "%" ~ "(n =" ~ .(bacteriaDistributionWithSpecieName$specieCount[i]) ~ ")")
  } else {
    bquote(italic(.(species_parts[1])) ~ "spp." ~ "-" ~ .(species_percentages[i]) ~ "%" ~ "(n =" ~ .(species_counts$species_count[i]) ~ ")")
  }
   
  # Add the legend text to the right of the chart
  text(x = 1.5, y = y_pos, labels = legend_text, adj = 0, cex = 0.8, xpd = TRUE)
  
  # Add the color box for each species to the right of the chart
  rect(xleft = 1.4, ybottom = y_pos - 0.02, xright = 1.45, ytop = y_pos + 0.02, col = color_palette[i], xpd = TRUE)
}

# Reset the plot margins to default
par(mar=c(5, 4, 4, 2) + 0.1)



```


## There were ST stat discussion in the paper, not sure if those changed ++0727



# Fig 5 - Venn Diagram

```{r fig5venn }


# https://www.geeksforgeeks.org/how-to-create-a-venn-diagram-in-r/
p_load(ggvenn)


# line 2344 of mission2022/guat_abricate_analy.Rmd
# just provide a list structure containing (3) lists, then draw the venn diagram...
# stVenn_list = list( `cc`=st_cc, `nc`=st_nc,  `tp`=st_tp   )  
# ggvenn(stVenn_list, show_elements=T, show_percentage=F, show_outside="always", text_size=1.1 ) +

# resultV2 has the most comprehensive info
# PubMLST_cheme_name is essentially Specie.  oh, can join that table too now.


# need a sample_vs_species_df 
sample_2_species_df = resultV2 %>%
  select( sample_name, Specie_Name, PubMLST_scheme_name, date, site, source, Sampling_Loc, key, Hnum, Lnum, DuplicateInfo  )
View( sample_2_species_df )


resGeneBySpecie = full_join(
  x  = resfinder_labeled_noDup,  # "pivot long" version
  y  = sample_2_species_df, 
  by = c( `key.x` = "key" ) 
)  

# tmp, just to get an idea species vs NUM_FOUND of resistance gene
resGeneBySpecie %>% group_by( Specie_Name )  %>% summarize( numResGene = n() )

resGeneBySpecieCount = resGeneBySpecie %>% 
  group_by( Specie_Name, gene )  %>% summarize( numResGene = n() )
  #group_by( Specie_Name, PRODUCT )  %>% summarize( numResGene = n() )
View( resGeneBySpecieCount )

df4venn_wide = resGeneBySpecieCount %>% 
  pivot_wider( names_from=Specie_Name, 
               values_from=numResGene)
View( df4venn_wide )
##^^ df4venn_wide  seems like the table I need to see overlap
##   many differences than the venn that TR has...  ++ 
##   55 rows (PRODUCTS), these are the proteins created by the resistance genes, avoid this complexity in paper, just use gene
##   62 rows (genes)
##   there is 1 PRODUCT as NA
##   resfinder_labelled as 63 col?

# checking num of uniq resistance genes
str( resfinder_labeled_noDup %>%
  #pull( PRODUCT ) %>%
  pull( gene ) %>%
  unique() 
)
# gene:    chr [1:61]   # I should use gene as well... subttle diff...  but overall df4venn_wide seems good.
# PRODUCT: chr [1:54] 

df4venn_wide_matrix = df4venn_wide %>% 
  mutate_at( 2:8, as.numeric ) %>% 
  select( -gene, -Other ) %>% 
  as.matrix()

df4venn_wide_matrix = df4venn_wide_matrix %>% replace(is.na(.), 0)

rownames( df4venn_wide_matrix ) = df4venn_wide$gene 

fig5alt = heatmap( df4venn_wide_matrix )
fig5alt

#  pheatmap::pheatmap( df4venn_wide_matrix )  # ugly

#

# heatmapMatrix = as.matrix( df4venn_wide %>% replace(is.na(.), 0)   ) 

### maybe much of below useless ...

#resGeneBySpecie %>% group_by( Specie_Name )  %>% summarize( PRODUCT )
## no need anymore due resGeneBySpecieCount  ?
## but good as aid to check
## mdf.A: I have only in E.coli and P.pputida, TR has it in Aeromonas spp. and Pseudomonas Aeruginosa as well.
df4venn = resGeneBySpecie %>% group_by( Specie_Name )  %>% reframe( gene ) # reframe( PRODUCT )   


df4venn_supplement = df4venn %>%
  mutate( count = 1 )

df4venn_wide = df4venn_supplement %>% 
  pivot_wider( names_from=Specie_Name, 
               values_from=count)

ResGene_Ecoli      = list( df4venn %>% filter( Specie_Name == "Escherichia coli"      ) %>% pull(gene) ) ;  # pull( PRODUCT ) ); 
ResGene_Ecoli = noquote(ResGene_Ecoli)


#ResGene_Klebsiella = list( df4venn %>% filter( Specie_Name == "Klebsiella pneumoniae" ) %>% pull( PRODUCT ) ); noquote(ResGene_Klebsiella)
ResGene_Klebsiella = list( df4venn %>% filter( Specie_Name == "Klebsiella pneumoniae" ) %>% pull( gene ) ); 
ResGene_Klebsiella = noquote(ResGene_Klebsiella)

# gua_abricate_analy.Rmd line 2324 use these noquote() thing...   but needed to save ?     those code weren't needed.  

ListOfList4venn = list( `ec`=ResGene_Ecoli, `k`=ResGene_Klebsiella )

# str( ResGene_Klebsiella )
str( ListOfList4venn )


# ggvenn(stVenn_list, show_elements=T, show_percentage=F, show_outside="always", text_size=1.1 ) +
ggvenn( ListOfList4venn, show_elements=T, show_percentage=F, show_outside="always", text_size=2.1 )
# above run, but unexpected result


# could I just feed a df to ggvenn?? 
#ggvenn( df4venn, columns = c( "Specie_Name" ), show_elements=T, show_percentage=F, show_outside="always", text_size=1.1 )
#ggvenn( df4venn, columns = c( 1 ), show_elements=T, show_percentage=F, show_outside="always", text_size=1.1 )

#ggvenn( df4venn, show_elements=T, show_percentage=F, show_outside="always", text_size=1.1 )


# no, genes are wide, not useful
# resGeneBySpecie = resultV2 %>% group_by( Specie_Name ) %>%  summarize( numResGene = n() )


# maybe do something like bacteriaDistributionWithSpecieName 


# played a lot in rstuff/venndiagram.Rmd, no good way to do this
# a pivot longer table and produce heat map?


```
############################################

# attempt 2 on venn diagram
# here actually just trying to get text output of intersections
# to be pasted manually in a diagram


```{r textVenn}

library(ggVennDiagram)

# Your sets
set1 <- c("A", "B", "C", "D", "E")
set2 <- c(     "B", "C", "D",       "F", "G")
set3 <- c(          "C", "D",            "G", "H", "I")
set4 <- c(               "D",            "G", "H",      "J")

# Create a list of sets
x <- list(Set1 = set1, Set2 = set2, Set3 = set3 , Set4 = set4)

# Function to get all intersections and unique elements
get_regions <- function(sets) {
  set_names <- names(sets)
  n <- length(sets)
  
  results <- list()
  
  # Get all intersections
  for (i in 1:n) {
    combs <- combn(set_names, i, simplify = FALSE)
    for (comb in combs) {
      intersection <- Reduce(intersect, sets[comb])
      if (length(intersection) > 0) {
        name <- paste(comb, collapse = "&")
        results[[name]] <- intersection
      }
    }
  }
  
  # Get unique elements for each set
  for (i in 1:n) {
    set_name <- set_names[i]
    unique_elements <- setdiff(sets[[i]], unlist(sets[-i]))
    if (length(unique_elements) > 0) {
      results[[paste0("Only_", set_name)]] <- unique_elements
    }
  }
  
  return(results)
}

# Get and print all regions
regions <- get_regions(x)

# Sort the regions to group "Only_" regions together
sorted_region_names <- sort(names(regions))

for (name in sorted_region_names) {
  cat("Region:", name, "\n")
  cat("Elements:", paste(regions[[name]], collapse = ", "), "\n\n")
}

# Create the Venn diagram
ggVennDiagram(x, label_alpha = 0)


# above print what is in each set correctly
# BUT it is not the content to be pasted into each overlap of a venn diagram.  
# eg Set1 & Set2 is right, but need more code to have Set1 & Set2 but not Set3.

## read carefully, Set1 is everything!  it is not what goes in the diagram of Set1 AND NOT (set2 & set3) 

```





############################################

# relevant/useful DF at the end

```{r usefulDF, eval=F }
View( resfinder_labeled )        # long format, has duplicate
View( resfinder_labeled_noDup )  # long format, duplicate filtered out
View( mlst_resfind_vfdb_df )     # wide format (summary) result
View( resultV2 )                 # most extensive DF, include Specie_Name, ST, all resistance and vfg, ecVF info.
View( sample_metadata )          # generated
View( sample_metadata_withDupInfo ) # hand edited to contain duplicate info on rows that need to be filtred out

```

############################################
############################################

# create new plot 
Reviewer #4 disliked the pie chart of Figure 4.  recommended stacked bar graph instead.
However, Tilden has 34 samples from water, 10 from shrimp.
Not sure which samples were selected.
The joined table above have ~55 rows.



# Notes about sequence files

most fasta files are about 480 - 550 MB.  But a few are 1210 MB!  ls -lS (it sorted by size, largest first)

-rw-rw-r-- 1 tin users 12115595 Nov 15  2023 AK_CKDN230030164-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users 10740528 Nov 15  2023 AU_CKDN230030174-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  9661854 Nov 15  2023 BA_CKDN230030180-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  9033176 Nov 15  2023 S_CKDN230030149-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  7035141 Nov 15  2023 E_CKDN230030138-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  6635702 Nov 15  2023 AE_CKDN230030158-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  6448173 Nov 15  2023 AV_CKDN230030175-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  5913388 Nov 15  2023 AZ_CKDN230030179-1A_HGKHYDSX7_L2.fasta
-rw-rw-r-- 1 tin users  5693370 Nov 15  2023 F_CKDN230030139-1A_HGKHYDSX7_L2.fasta
...
-rw-rw-r-- 1 tin users  4505363 Nov 15  2023 Z_CKDN230030153-1A_HGKHYDSX7_L2.fasta





